
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Teoria sulle Misure Responsive</title>
 

<style>

html {font-size: 100%; scroll-behavior: smooth;  scroll-padding-top: 1rem;}

body {
    display: flex;
justify-content: center;
align-items: center;
width: 100%;
height: 100%;
color: #333;
line-height: 1.3;
background-color: white;
    opacity: 0;
    transition: opacity 0.7s ease-in-out;
}

:root {
    --img-width: min(90rem, 100vw);
    --contenitore-width: min(90rem, 100vw);
}


.contenitoremax {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    width: var(--contenitore-width);

    margin: 0 auto; /* Lo mantiene centrato */
    background-color: yellow;

}

* {
font-family: 'Helvetica', 'Arial', sans-serif;
margin: 0;
padding: 0;
box-sizing: border-box;
}



header {
    display: flex;
justify-content: center;
align-items: center;
    font-weight: bold;
    color: #FFCF00;
    background-color: #013642;
    margin-bottom: 1rem;
 width: 100%;
// max-width: var(--img-width);
padding: 1rem 0 1rem 0;
    }

header span {
font-size: var(--font-size-header);
}

.nowrap {
    white-space: nowrap;
font-size: var(--font-size-header);
}

.multi-line {
    white-space: normal;
    display: block;
    text-align: center;
}

 .immagine-container {
  width: 100%;
      height: auto;
    margin: 0; 
    padding: 0; 
    // background-color: #000601; /* Placeholder fino al caricamento */
    overflow: auto;

      text-align: center; /* Centra orizzontalmente */
}

.immagine-container img {
    display: block;
 width: var(--img-width);
// max-width: 100vw;

   height: auto; 
margin: 0 auto;
    border-top: 0.6rem solid #a10211;
    border-bottom: 0.6rem solid #a10211;
    padding: 0; 

}


.utilizzo {
// max-width: var(--img-width);
width: 100%;
font-weight: bold;
    display: flex;
align-items: center;
color: white;
background-color: #013642;
padding: 0.5rem 1.5rem 0.5rem 1.5rem;
margin: 1rem 0 2rem 0;
}


.tstutil {
 text-align: justify;
font-size: var(--font-size-tstutil);
 will-change: transform, opacity;
  hyphens: auto;
  word-break: break-word;
}

.funzionalitÃ  {
margin: 0 6vw 3.3vw 6vw; 
border-top: 0.8rem solid red;
// overflow: hidden;
box-sizing: border-box;
}

.funzionalitÃ  p.titolo {
font-size: var(--font-size-funztit);
font-weight: 900;
color: #025669;
}

.funzionalitÃ  p, .testospieg p {
font-size: var(--font-size-funzion);
text-align: justify;
margin-top: 0.4rem;
  hyphens: auto;
  word-break: break-word;
}


    </style>
</head>
<body>

<div class="contenitoremax">

   <header>  <span>- Simulatore di device per <span class="nowrap">Siti responsive -</span></span></header>

 <div class="immagine-container">
<img src="device-min-min.webp" alt="Descrizione dell'immagine">
    </div>


<div class="utilizzo">
<p class="tstutil">Per il miglior utilizzo, accedere al sito esclusivamente da un PC desktop o laptop.</br>
Questo strumento Ã¨ pensato per simulare dispositivi mobili e non Ã¨ utilizzabile su smartphone o tablet.</p>
</div>


<div class="funzionalitÃ ">
  <p class="titolo">Introduzione alla Teoria dei Pixel e del Rendering Grafico</p>
  <p>Questa pagina Ã¨ dedicata alla comprensione delle basi tecniche che influenzano la visualizzazione dei siti web sui diversi dispositivi.</p> 
  <p>Comprendere questi concetti ti consentirÃ  di progettare siti web ottimizzati per garantire unâ€™esperienza utente eccellente su qualsiasi schermo.</p>
  <p>Affronteremo concetti fondamentali come i pixel reali e i pixel CSS, la risoluzione dello schermo, il rapporto d'aspetto, il PPI e il Device Pixel Ratio (DPR), oltre a concetti correlati come anti-aliasing e interpolazione.</p>
  <p>Queste conoscenze non solo ti aiuteranno a ottimizzare il design responsivo, ma ti permetteranno anche di comprendere come i dispositivi e i browser interpretano e gestiscono i contenuti grafici.</p>
</div>

</div>
<script>



// Mappa delle dimensioni del font per ogni intervallo
const fontSizeMap = [
                                   [7000, 1441, 3, 1.5, 2.2, 1.5],
    [1440, 1361, 3, 1.5, 2.2, 1.5], [1360, 1280, 2.8, 1.4, 2.1, 1.5],
    [1279, 1195, 2.6, 1.4, 2.0, 1.4], [1194, 1111, 2.5, 1.2, 1.9, 1.4],
    [1110, 1024, 2.4, 1.3, 1.7, 1.4], [1023, 939, 2.3, 1.2, 1.6, 1.4],
    [938, 852, 2.2, 1.1, 1.5, 1.3], [851, 768, 2.0, 1.0, 1.5, 1.2],
    [767, 685, 1.8, 1.0, 1.5, 1.2], [684, 600, 1.7, 1.0, 1.5, 1.1],
    [599, 541, 1.6, 0.9, 1.5, 1.1], [540, 480, 1.5, 0.87, 1.4, 1.1],
    [479, 400, 1.5, 0.8, 1.5, 1.0], [399, 341, 1.5, 0.75, 1.5, 0.9],
    [340, 291, 1.4, 0.7, 1.5, 0.9], [290, 256, 1.1, 0.67, 1.5, 0.9],
    [255, 220, 1.0, 0.63, 1.5, 0.9], [219, 200, 0.8, 0.6, 1.5, 0.9],
    [199, 160, 0.7, 0.55, 1.5, 0.9], [159, 145, 0.6, 0.55, 1.5, 0.9],
    [144, 120, 0.5, 0.5, 1.5, 0.9], [119, 95, 0.4, 0.5, 1.5, 0.8], 
    [94, 75, 0.3, 0.4, 1.5, 0.7], [74, 49, 0.2, 0.3, 1.5, 0.5]
];


// Ultima larghezza registrata per evitare doppie stampe
let lastBodyWidth = null;

// Funzione per aggiornare i font in base alla larghezza del body
function aggiornaFont(min, max) {
    const larghezzaBody = document.documentElement.clientWidth;
   // console.clear();
    console.log(`ðŸ”„ Larghezza attuale: ${larghezzaBody}px | Range attivo: ${min}px - ${max}px`);

    for (const [rangeMax, rangeMin, headerSize, tstutilSize, funztitSize, funzionSize] of fontSizeMap) {
        if (larghezzaBody <= rangeMax && larghezzaBody >= rangeMin) {
            document.documentElement.style.setProperty('--font-size-header', `${headerSize}rem`);
            document.documentElement.style.setProperty('--font-size-tstutil', `${tstutilSize}rem`);
            document.documentElement.style.setProperty('--font-size-funztit', `${funztitSize}rem`);
            document.documentElement.style.setProperty('--font-size-funzion', `${funzionSize}rem`);
            break;
        }
    }
}




window.addEventListener("load", () => {    

     requestIdleCallback(() => { // Esegue solo quando il browser Ã¨ pronto
        const larghezzaBody = document.documentElement.clientWidth;
        console.log("ðŸ“ Larghezza del body Ã¨", larghezzaBody);

        const intervalloAttuale = fontSizeMap.find(([max, min]) => larghezzaBody <= max && larghezzaBody >= min);

        if (intervalloAttuale) {
            const [max, min] = intervalloAttuale;
            aggiornaFont(min, max);
        } else {
            console.warn("âŒ Nessun intervallo trovato per questa larghezza!");
        }

        aggiornaMultiLine();

        document.body.style.opacity = "1"; // Mostra il sito dopo il calcolo
       // calcolaLarghezzaImmagine(larghezzaBody);

    });
});





fontSizeMap.forEach(([max, min]) => {
    const mediaQuery = window.matchMedia(`(min-width: ${min}px) and (max-width: ${max}px)`);
    
    mediaQuery.addEventListener("change", (e) => {
        if (e.matches) {
            aggiornaFont(min, max); // Passiamo il range attivo a aggiornaFont
            aggiornaMultiLine();
        }
    });
});

function aggiornaMultiLine() {
    const larghezzaBody = document.documentElement.clientWidth;
    document.querySelector(".nowrap")?.classList.toggle("multi-line", larghezzaBody <= 640);
}

function getDPRNativo() {
    let dprSalvato = localStorage.getItem('DPR_NATIVO');
    
    if (dprSalvato) {
        return parseFloat(dprSalvato); // Usa il valore salvato se disponibile
    } else {
        let dpr = window.devicePixelRatio || 1; // Calcola il DPR iniziale
        localStorage.setItem('DPR_NATIVO', dpr); // Lo memorizza
        return dpr;
    }
}

const DPR_NATIVO = getDPRNativo(); // Ora il DPR Ã¨ stabile e non cambia al refresh

function calcolaZoom() {
    return Math.round((window.devicePixelRatio / DPR_NATIVO) * 100);
}

console.log("DPR NATIVO", DPR_NATIVO);


function calcolaMinWidth() {
    let remInPx = parseFloat(getComputedStyle(document.documentElement).fontSize); // Ottiene 1rem in pixel
    let width90rem = 90 * remInPx; // Calcola 90rem in pixel
    let width100vw = window.innerWidth; // Ottiene 100vw in pixel
    return Math.min(width90rem, width100vw); // Prende il valore piÃ¹ piccolo tra 90rem e 100vw
}

function aggiornaLarghezzaContenitore() {
    let zoomAttuale = calcolaZoom();
    let larghezzaDisponibile = document.documentElement.clientWidth;
    let larghezzaSchermo = screen.width; // Larghezza nativa dello schermo

    if (zoomAttuale >= 100) {
      console.log("Lo zoom Ã¨ maggiore di 100");
        // Se lo zoom Ã¨ â‰¥100% o il resize Ã¨ >= larghezza schermo, espandi il contenitore
        document.documentElement.style.setProperty('--contenitore-width', `${larghezzaDisponibile}px`);
        document.documentElement.style.setProperty('--img-width', `${larghezzaDisponibile}px`);
    } else {   
        console.log("Lo zoom Ã¨ minore di 100");
        // Se lo zoom scende sotto il 100%, assegniamo manualmente il valore di min(90rem, 100vw)
        let larghezzaMin = calcolaMinWidth();
       console.log("larghezzaMin Ã¨", larghezzaMin);
        document.documentElement.style.setProperty('--contenitore-width', `${larghezzaMin}px`);
        document.documentElement.style.setProperty('--img-width', `${larghezzaMin}px`);
    }

    console.log(`Zoom: ${zoomAttuale}% | Larghezza viewport: ${larghezzaDisponibile}px | Larghezza schermo: ${larghezzaSchermo}px | 90rem in px: ${90 * parseFloat(getComputedStyle(document.documentElement).fontSize)}`);
}

// Esegui solo al caricamento se lo zoom Ã¨ â‰¥100%
if (calcolaZoom() >= 100) {
    aggiornaLarghezzaContenitore();
}

// Aggiungi il listener per resize e zoom dinamico
window.addEventListener('resize', aggiornaLarghezzaContenitore);
// window.addEventListener('wheel', () => setTimeout(aggiornaLarghezzaContenitore, 200)); // Gestisce lo zoom dinamicamente
window.addEventListener('keydown', (e) => {
    if (e.ctrlKey && (e.key === '+' || e.key === '-')) {
        setTimeout(aggiornaLarghezzaContenitore, 200); // Zoom con CTRL +/-
    }
});


</script>


</body>
</html>


